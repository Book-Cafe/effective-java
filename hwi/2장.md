### 아이템 1. 생성자 대신 정적 팩토리 메서드를 고려하라

#### 장점
+ 정적 팩토리 메서드는 생성자보다 유연하고 명확하다.
+ 이름 짓기를 통해 객체 생성의 목적을 명확하게 표현할 수 있다.
+ 하위 타입을 생성해서 리턴, 이미 생성된 인스턴스를 리턴 등 인스턴스를 반드시 생성하는 생성자와 다르게 유연성이 있다.
+ 유연하게 기능을 작성하고 이름을 알맞게 짓는다면 여러 상황에서 유용하게 사용할 수 있다.

<br>

#### 단점
+ 생성자를 private로 막기 때문에 상속이 불가능하다.
+ 정적 팩토리 메서드가 존재하는지 확인해봐야 한다. -> 이 때문에 대중화된 정적 팩토리 메서드의 이름들이 존재함

<br>

#### 내가 생각하는 핵심
+ 정적 팩토리 메서드는 유연성과 명확성이 핵심이다. 
+ 클래스를 생성할 때, 단순하게 인스턴스를 생성하여 리턴하는 객체는 유연성과 명확성이 필요하지 않다.
+ 그래서 정적 팩토리 메서드를 사용하지 않고 생성자를 사용해도 괜찮을 것 같다.

<br><br>


### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

#### 장점
+ 불완전한 객체가 아닌 하나의 완전한 객체를 생성할 수 있다.
+ 매개 변수가 여러개가 있어도 가독성이 좋다.
+ 생성자를 여러 개 만들 필요가 없다.
+ 각 필드의 메서드마다 유효성 검사를 진행할 수 있어서 가독성이 좋다.
+ 매개 변수에 따라 다른 객체를 리턴하는 유연함을 가질 수 있다.

<br>

#### 단점
+ 상속이 불가능하다.
+ 빌더를 위한 코드를 작성해야 한다.
+ 매개 변수가 3개 이하라면 사용하기 과하다. 

<br>

#### 내가 생각하는 핵심
+ 매개 변수가 많다면 문제가 생길 가능성이 높아진다.
+ 이 때 빌더 패턴을 사용하면 가독성이 높아져서 문제가 생길 확률이 줄어든다.
+ 보통은 매개 변수가 4개 이상부터 사용을 추천하지만 소프트웨어는 점점 복잡해지는 경향이 있다.
+ 그래서 매개 변수가 4개보다 작더라도 점점 기능이 확장될 것으로 예상되는 클래스가 있다면 처음부터 빌더 패턴을 사용해도 좋을 것 같다.

<br><br>


### 아이템 3. private 생성자나 열거 타입으로 싱글톤임을 보증하라

#### 구현 방식
+ 필드에 싱글톤 객체를 생성하고 public하게 열어 놓는 방식
+ 필드를 private하게 놓고 정적 팩토리 메서드를 통해 접근하는 방식
    + 유연함이 필요한 상황이 아니라면 첫 번째 방식이 낫다.
+ 열거 타입을 사용해서 싱글톤을 보장하는 방식

<br>

#### 내가 생각하는 핵심
+ 무상태 객체이거나 시스템 상 하나만 존재해야 하는 객체라면 싱글톤 객체를 고려하자.
+ 열거 타입이 아닌 경우 리플렉션과 직렬화로 인해 싱글톤이 깨지는 경우를 조심해라.
+ 싱글톤 객체는 테스트하기가 어려워질 수 있다.

<br><br>


### 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

#### 내가 생각하는 핵심
+ 인스턴스를 허용하지 않는다면 생성자를 private로 설정해라.
+ 정적 메서드는 동일한 값을 입력하면 항상 동일한 값이 리턴되어야 한다.
+ 만약 특정 조건에 따라 리턴값이 달라지게 되면 정적 메서드로 만들면 안된다.
+ final 클래스와 관련된 메서드를 모을 때도 활용할 수 있다.

<br><br>


### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

#### 내가 생각하는 핵심
+ 객체 내부에서 다른 객체를 생성하게 되면 결합도가 높아지게 된다.
+ 이 때, 의존 관계 주입을 사용하면 유연하고 재사용성이 높아지고 테스트하기 쉬워진다.
+ 사용하는 자원에 따라 동작이 달라진다면, 정적 유틸리티 클래스나 싱글톤 객체로 생성 X

<br><br>


### 아이템 6. 불필요한 객체 생성을 피하라

#### 내가 생각하는 핵심
+ 똑같은 기능을 동작하는 클래스는 하나만 만들자.
+ 무거운 객체는 캐싱을 고려해보자.
+ 오토 박싱은 불 필요한 객체를 만들 수 있다.
+ 객체의 생성 이유가 명확성, 간결성이라면 객체를 추가적으로 생성해야 한다.
+ 방어적 복사가 필요한 곳에는 객체를 재사용하지 마라!

<br><br>


### 아이템 7. 다 쓴 객체 참조를 해제하라

#### 내가 생각하는 핵심
+ 메모리 누수는 발견하기 어렵다.
+ 그래서 클래스나 캐시에서는 다 쓴 객체가 생기면 바로 참조를 해제하자.
+ 클래스에서 사용이 끝난 객체는 null 처리를 한다.
+ 캐시에서는 WeekHashMap을 사용하거나 오래된 엔트리의 가치를 떨어뜨린다.

<br><br>


### 아이템 8. finalizer와 cleaner 사용을 피해라

#### 내가 생각하는 핵심
+ finalizer와 cleaner는 언제 실행될지 알 수 없고, 실행이 보장되지도 않는다.
+ 네이티브 리소스를 회수하거나, 까먹고 리소스를 회수하지 못한 객체를 회수할 때 도움은 된다.
+ 하지만 이 조차 try-with-resources로 해결 가능하다.
+ try-with-resources를 사용하자!

<br><br>


### 아이템 9. try-finally보다는 try-with-resources를 사용하라

#### 장점
+ 가독성이 좋아져서 문제를 파악하기 쉽다.
+ try 내부에서 에러가 발생하고 close에서 에러가 발생해도, try 내부의 에러가 발생한다.

<br>

#### 내가 생각하는 핵심
+ 리소스를 회수해야 할 일이 있다면 try-with-resources를 적극적으로 사용하자.
