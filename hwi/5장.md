### 아이템 26. 로 타입을 사용하지 말자

#### 내가 생각하는 핵심
+ 오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.
+ 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
+ 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자.
+ Collection<?>에는 (null 외에는) 어떤 원소도 넣을 수 없다.
+ class 리터럴에는 로 타입을 써야 한다.(배열과 기본 타입은 허용한다.)
+ 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다.
+ 런타임에는 제네릭 타입 정보가 지워지므로 instanceOf 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
+ 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.

<br><br>

### 아이템 27. 비검사 경고를 제거하라

#### 내가 생각하는 핵심
+ 할 수 있는 한 모든 비검사 경고를 제거하라. 모두 제거한다면 그 코드는 타입 안전성이 보장된다.
+ 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarning("unchecked) 애너테이션을 달아 경고를 숨기자.
+ @SuppressWarning 애너테이션은 항상 가능한 한 좁은 범위에 적용하자.

<br><br>


### 아이템 28. 배열보다는 리스트를 사용하라

#### 내가 생각하는 핵심
+ 배열은 공변이고 제네릭은 불공변이다.
+ 배열은 실체화되고 제네릭은 타입 정보가 런타임에는 소거된다.
+ 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용될 수 없다.
+ 비한정적 타입은 타입 정보가 없기 때문에 실체화 타입으로 본다.(Object로 변환됨)
+ 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 오류가 뜨는 경우 대부분은 List<E>를 사용하면 해결된다.

<br><br>


### 아이템 29. 이왕이면 제네릭 타입으로 만들라

#### 내가 생각하는 핵심
+ 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.

<br><br>


### 아이템 30. 이왕이면 제네릭 메서드로 만들라

#### 내가 생각하는 핵심
+ 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다.

<br><br>


### 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라

#### 내가 생각하는 핵심
+ 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드 타입을 사용하라.
+ 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없다. 타입을 정확히 지정해야 하는 상황으로, 이때는 와일드카드 타입을 쓰지 말아야 한다.
+ 매개변수화 타입 T가 생성자라면 <? extends T>를 사용하고, 소비자라면 <? super T>를 사용하라.
+ 반환 타입에는 한정적 와일드카드 타입을 사용하면 안 된다.
+ 클래스의 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.
+ 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라.
+ Comparable과 Comparator는 모두 소비자라는 사실도 잊지 말자.

<br><br>


### 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

#### 내가 생각하는 핵심
+ 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.
+ @SafeVarargs 애너테이션은 메서드 작성자가 그 메서드의 타입 안전함을 보장하는 장치다.
+ 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarargs를 달라. 이 말은 안전하지 않은 varargs 메서드는 절대 작성해서는 안 된다는 뜻이다.
+ @SafeVarargs 애너테이션은 재정의할 수 없는 메서드에만 달아야 한다.
+ @SafeVarargs 애너테이션이 유일한 정답은 아니다. 아이템 28의 조언을 따라 List 매개변수로 바꿀 수도 있다.

<br><br>


### 아이템 33. 타입 안전 이종 컨테이너를 고려하라

#### 내가 생각하는 핵심
+ class 리터럴의 타입은 Class가 아닌 Class<T>다.
+ 컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수가 고정되어 있다.
+ 하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다.
+ 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다.

<br><br>
